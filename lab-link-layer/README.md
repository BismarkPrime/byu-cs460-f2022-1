# Link-Layer Lab

The objective of this assignment is to give you hands-on experience with the
link layer, local area networks (LANs), switching, and virtual LANs (VLANs), by
implementing a link-layer switch!


# Getting Started

## Update Cougarnet

Make sure you have the most up-to-date version of Cougarnet installed by
running the following in your `cougarnet` directory:

```
$ git pull
$ python3 setup.py build
$ sudo python3 setup.py install
```

Remember that you can always get the most up-to-date documentation for
Cougarnet [here](https://github.com/cdeccio/cougarnet/blob/main/README.md).


## Resources Provided

The files given to you for this lab are the following:
 - `switch.py` - a file containing a stub implementation of a switch. This is
   where you will do your work!
 - `host.py` - a script that will be run on every host.  It does two things:
   - [Sends a log message to the calling process](https://github.com/cdeccio/cougarnet/blob/main/README.md#communicating-with-the-calling-process),
     which will be printed out to the terminal on which the calling process is
     running.
   - Sends frames to other hosts on the network at certain times relative to
     the start of the simulation, depending on the name of the host on which it
     is running.
 - `scenario1.cfg`, `scenario2.cfg`, `scenario3.cfg` -
   [network configuration files](https://github.com/cdeccio/cougarnet/blob/main/README.md#network-configuration-file)
   describing three link-layer topologies.
 - `scenario1a.cfg` - a variant of `scenario1.cfg`, designed to show how things
   might operate with a real switch.


## Starter Commands

Take a look at the contents of `scenario1a.cfg`.  Then run the following to
start it up:

```
$ cougarnet --display scenario1a.cfg
```

You will notice that, by default, terminal windows appear for every host and
for the switch.  You can disable this with the `--terminal=none` option, but
first take note of these other things:

 - All terminals, except the one for the switch, display the
   [command that is being run](https://github.com/cdeccio/cougarnet#running-programs)--instead
   of the shell.  This is specified for each host in `scenario1a.cfg`.
 - The calling `cougarnet` process prints out a bunch of log messages.  Most of
   those are related to activity associated with Open vSwitch, which is
   performing `s1`'s switching operations during this execution (but will not
   be present when your switch is running instead--i.e., with `scenario1.cfg`).
   However, somewhere after the 4-second time, you will see log messages
   associated with frames created in conjunction with this lab.  These will
   have MAC addresses that are given to hosts in the configuration file (e.g.,
   `00:00:00:aa:aa:aa`), and they are generated by the `host.py` script.

Now look at the contents of `scenario1.cfg`, and run the following to start it
up:

```
$ cougarnet --display --native-apps=none scenario1.cfg
```

It is similar in some senses, but very different in some others.  Note the
following:

 - Some frames are still being logged by the host, but they are fewer.
 - After the 4-second time, there is effectively nothing being logged by any of
   the hosts.
 - The switch is printing (to standard output) strange-looking strings.

What is going on?  Well, there is no switch functionality written in
`switch.py`; the script is simply printing out the representation of the frames
that it is seeing on its interfaces.  Your job, of course, is to flesh out the
switch functionality, so that running the second command (i.e., for
`scenario1.cfg`) results in output more like that produced by the first
command.  That is, you will create a working link-layer switch!


## Scenario Descriptions

Your working switch should work in the following three scenarios, described in
the files `scenario1.cfg`, `scenario2.cfg`, and `scenario3.cfg`, respectively.

### Scenario 1

Scenario 1 is a simple scenario in which hosts `a`, `b`, `c`, `d`, and `e` are
all connected to a single switch, `s1`.  There are no VLANs or trunking.
```
          +---+
          | a |
          +---+
            |
            |
            |
+---+     +--------+
| c | --- |        |
+---+     |   s1   |
+---+     |        |
| d | --- |        |
+---+     +--------+
            |    |
            |    |
            |    |
          +---++---+
          | e || b |
          +---++---+
```


### Scenario 2

In scenario 2 hosts `a` and `b` are connected to switch `s1`, hosts `c`, `d`,
and `e` are connected to switch `s2`, and hosts `s1` and `s2` are connected to
each another.  There are no VLANs or trunking.
```
          +----+
          | a  |
          +----+
            |
            |
            |
+---+     +----+
| b | --- | s1 |
+---+     +----+
            |
            |
            |
+---+     +----+     +---+
| d | --- | s2 | --- | e |
+---+     +----+     +---+
            |
            |
            |
          +----+
          | c  |
          +----+
```

### Scenario 3

In scenario 3 hosts `a` and `b` are connected to switch `s1`, hosts `c`, `d`,
and `e` are connected to switch `s2`, and hosts `s1` and `s2` are connected to
each another.  Hosts `a`, `c`, and `e` are on VLAN 10, and hosts `b` and `d`
are on VLAN 20.  The connection between switches `s1` and `s2` is a trunk.
```
          +----+
          | a  |
          +----+
            |
            |
            |
+---+     +----+
| b | --- | s1 |
+---+     +----+
            |
            |
            |
+---+     +----+     +---+
| d | --- | s2 | --- | e |
+---+     +----+     +---+
            |
            |
            |
          +----+
          | c  |
          +----+
```

## Frames Issued

In every scenario, the following frames are sent at the following times (note
that times are approximate).  Each sub-bullet describes the purpose of the primary
bullet under which it is listed.  That is, it describes what is being tested.

 - 4 seconds: frame sent from `a` to `c`
   - There is no table entry for `a`
 - 5 seconds: frame sent from `c` to `a`
   - There is a table entry for `a`
 - 6 seconds: frame sent from `a` to `c`
   - There is a table entry for `c`
 - 7 seconds: frame sent from `a` to broadcast
   - Broadcast is always sent to all interfaces on the LAN or VLAN
 - 8 seconds: frame sent from `e` to `a`
   - Establish a table entry for `a`
 - 9 seconds: frame sent from `a` to `e`
   - There is a table entry for `e`
 - 10 seconds: frame sent "from" `e` (spoofed from `c`'s port) to `a`
   - Establish a new table entry for `a`
 - 11 seconds: frame sent from `a` to `e`
   - There is new a table entry for `e`
 - 14 seconds: frame sent from `e` to `a`
   - The table entry for `a` has not expired
 - 15 seconds: frame sent from `a` to `c`
   - The table entry for `c` has expired


# Instructions

## Part 1 - Link-Layer Forwarding and Learning

Read Section 6.4.3 ("Link-Layer Switches") in the book, especially the
sub-sections "Forwarding and Filtering" and "Self-Learning", and especially
pages 492 and 493.  Then implement a basic switch in `switch.py` with the
following functionality:

 - The switch has a MAC address table mapping MAC addresses to interfaces.
 - The MAC address table is initialized as an empty mapping.
 - A new table entry is added or an existing entry updated with every incoming
   frame.
 - The aging time of a new table entry is 8 seconds.  When a frame arrives
   corresponding to an existing entry, its aging time is reset to 8 seconds.
 - Table entries are purged as their aging time expires.
 - A non-broadcast frames is forwarded as-is (unchanged) to the interface
   corresponding to the table entry of the destination MAC address, if such an
   entry exists; if no entry exists, then it is forwarded to every interface,
   except that from which it originated.
 - A broadcast frame (i.e., having destination MAC address `ff:ff:ff:ff:ff:ff`)
   is forwarded as-is to all interfaces, except that from it originated.

Test your implementation against scenarios 1 and 2.  Determine the appropriate
output--that is, which hosts should receive which frames--and make sure that
the output for your switch implementation matches appropriately.

When it is working properly, test also with the `--terminal=none` option:

```
$ cougarnet --native-apps=none --terminal=none scenario1.cfg
$ cougarnet --native-apps=none --terminal=none scenario2.cfg
```


## Part 2 - VLANs and Trunking

Read Section 6.4.4 ("Virtual Local Area Networks (VLANs)") in the book.  Then
add implementation for VLANs and trunking according to the following:

 - When the switch is initialized, associate each interface port with a VLAN,
   with a trunk, or with neither.  This is done by looking for the presence of
   environment variables in your script, as described in the
   [documentation](https://github.com/cdeccio/cougarnet#vlan-attributes).
   Note that for a given switch configuration either 1) all interfaces are
   either VLANs or trunks, or 2) no interfaces are VLANs or trunks,
   [as documented](https://github.com/cdeccio/cougarnet/blob/main/README.md#configuration-1).
 - A frame should only ever be forwarded to interfaces that share the same VLAN
   as the interface from which it originated, or to a trunk interface.  This is
   true whether a table entry exists for a given MAC address, no entry exists,
   or the destination MAC address of the frame is the broadcast address.
 - When a frame is sent to a trunk port, it should be converted to an 802.1Q
   frame, such that the frame header includes the VLAN ID, in addition to the
   rest of the frame header, and the original payload.
 - When a frame is received on a trunk port, it should be converted from an
   802.1Q frame to a vanilla Ethernet frame.  The VLAN ID should be extracted,
   and used to determine the interface(s) (if any) to which the frame should be
   forwarded.

Test your implementation against scenarios 1, 2, and 3.  Determine the
appropriate output--that is, which hosts should receive which frames--and make
sure that the output for your switch implementation matches appropriately.
Note that scenarios 1 and 2 do not include VLANs, but your switch should still
work for those scenarios.

When it is working properly, test also with the `--terminal=none` option:

```
$ cougarnet --native-apps=none --terminal=none scenario1.cfg
$ cougarnet --native-apps=none --terminal=none scenario2.cfg
$ cougarnet --native-apps=none --terminal=none scenario3.cfg
```

## Helps

### Ethernet Frames

Your code will need to parse Ethernet frames from the "wire" as a `bytes`
instances.  The frame that you will be receiving looks like this:

| Source MAC Addr | Destination MAC Addr | EtherType | Payload |
| :---: | :---: | :---: | :---: |
| (48 bits) | (48 bits) | (16 bits) | (variable) |

Note that a complete Ethernet frame also has fields for preamble and Cyclic
Redundancy Check (CRC) when it actually travels on the wire.  However, these
frames are read from a raw socket (i.e., of type `SOCK_RAW`, as opposed to
`SOCK_STREAM` or `SOCK_DGRAM`), and those two fields are stripped before it is
passed to the application.

In the case of 802.1Q, the frame will look like this:

| Source MAC Addr | Destination MAC Addr | 802.1Q Header | EtherType | Payload |
| :---: | :---: | :---: | :---: | :---: |
| (48 bits) | (48 bits) | (32 bits) | (16 bits) | (variable) |

The most signficant (left-most) 16 bits of the 802.1Q header should have the
value 0x8100 to indicate that it is an 802.1Q frame.  The least significant
(right-most) 12 bits of the 802.1Q header should contain the value of the VLAN ID.
The 4 bits in between can be left as zero.


You can index into `bytes` instances (e.g., `foo[0]`), take slices (e.g.,
`foo[2:4`), and concatenate them together (e.g., `foo + bar`).  I also
recommend checking out the following modules that, together with the `bytes`
operations, will help you parse, take apart, and put together Ethernet frames:
`binascii`, `struct`.

Note that there are libraries for parsing Ethernet frames and higher-level
packets, but you may not use them for the lab.


### Sending and Receiving Frames

Sending and receiving frames is described in the
[documentation](https://github.com/cdeccio/cougarnet/blob/main/README.md#sending-and-receiving-frames).


### Other Helps

 - Use Wireshark to see what is going on!  This is probably most helpful by
   running `cougarnet` using `--wireshark=s1`.
 - Print to standard out for debugging purposes.  For a script running in a
   virtual host (i.e., with the `prog` option), all output will go to the
   terminal associated with that host, assuming `terminal=false` is not used in
   the configuration file and `--terminal=none` is not used on the command
   line.  See
   [the documentation](https://github.com/cdeccio/cougarnet/blob/main/README.md#additional-options).
   for more.
 - You can modify `host.py` and the scenario files all you want for testing and
   for experimentation.  If this helps you, please do it!  Just note that your
   submission will be graded using only your `switch.py`; the `host.py` and
   scenario files used will be the stock files [you were provided](#resources-provided).
 - Save your work often, especially after you finish Part 1 and move on to
   Part 2.  You are welcome (and encouraged) to use a version control
   repository, such as GitHub.  However, please ensure that it is a private repository!


# Submission

Upload your functional `switch.py` to the assignment page on LearningSuite.
